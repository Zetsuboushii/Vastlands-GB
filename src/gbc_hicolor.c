// TODO: Permissive License

#include <gbdk/platform.h>
#include <gbdk/incbin.h>
#include <gb/isr.h>

#include <gbc_hicolor.h>

#define MIN(A,B) ((A)<(B)?(A):(B))

static uint16_t SP_SAVE;
static uint8_t STAT_SAVE;
static uint8_t * p_hicolor_palettes;
static uint8_t hicolor_palettes_bank;
static uint8_t hicolor_last_scanline;

static uint16_t hicolor_palettes_cur_addr;


// ISR function which updates 4 CGB palettes per scanline
// alternating between Palettes 0-3 and 4-7
void hicolor_palette_isr(void) NONBANKED {

__asm
    PALETTES_PER_LINE       = #4 ; How many palettes are transferred per scanline
    PAL_BYTES_PER_LINE      = #PALETTES_PER_LINE * #4 * #2 ; 4 colors/palette × 2 bytes/color
    BYTES_TO_NEXT_PAL_LINE  = #PAL_BYTES_PER_LINE * #2 + #1 + #1 - #4 // + (halt + ret) - (4 pre-load bytes)

    BYTES_TO_PAL_AFTER_VBLANK_PAL = #8 * #4 * #2 * #2 + #1; // 8 palettes × 4 colors/palette × 2 bytes/palette × `ld [hl], <byte>` + `ret`

    ldh a, (__current_bank)     ; switch ROM bank
    push af
    ld a, (_hicolor_palettes_bank)
    or a
    jr z, 0$  ; hicol__skip_set_bank_if_zero
    ldh (__current_bank), a
    ld (_rROMB0), a

0$:  ; hicol__skip_set_bank_if_zero

    ; Set return address used by vblank palette load
    ld hl, #1$  ; #_hicol__vblank_load_pal_done_ret
    push hl

    ; Set address to start of palette load code, ret below will jump to this
    ld hl, #_p_hicolor_palettes
    ld a,  (hl+)
    ld h,  (hl)
    ld l,  a
    push   hl

    ; Save palette buffer address for incrementing below
    ld b, h
    ld c, l

    ; Set palette auto-increment and end with
    ; HL pointing to BCPD, which the palette load expects
    ld a, #BCPSF_AUTOINC
    ld hl, #_BCPS_REG
    ld (hl+), a
    ret ; Jump to the palette load code

; Execution resumes here after vblank palette load returns
1$:  ; hicol__vblank_load_pal_done_ret

    ; Calculate palette buffer execution start for next line, store to HL
    ; BC has saved palette buffer address from earlier
    ld a, c
    add  a, #BYTES_TO_PAL_AFTER_VBLANK_PAL
    ld   l, a
    ld   a, b
    adc  a, #0
    ld   h, a

    2$:  ; hicol__vbl_wait_mode_3
        ldh a, (_STAT_REG)
        and #STATF_BUSY
        jr z, 2$  ; ._hicol__vbl_wait_mode_3  ; wait for mode 3

    ldh a, (_STAT_REG)
    ld (_STAT_SAVE), a

    ld a, #STATF_MODE00
    ldh (_STAT_REG), a
    xor a
    ldh (_IF_REG), a

    ; Skip first scanline palette buffer address adjustment
    ; since it was already calculated during vblank
    jr 3$  ; hicol__scanline_load_start_from_vblank

    4$:  ; hicol__scanline_load_start
        ; Load current palette buffer address
        ; Calculate palette load execution start for next line, store to HL
        ld a, (_hicolor_palettes_cur_addr + 0)
        add a, #BYTES_TO_NEXT_PAL_LINE
        ld l, a
        ld a, (_hicolor_palettes_cur_addr + 1)
        adc a, #0
        ld h, a

    3$:  ; hicol__scanline_load_start_from_vblank

        ; Set address used for hblank palette load to return to
        ld de, #5$  ; hicol__hblank_load_pal_done_ret
        push de

        ; Preload the first four bytes
        ld a, (hl+)
        ld b, a
        ld a, (hl+)
        ld c, a
        ld a, (hl+)
        ld d, a
        ld a, (hl+)
        ld e, a

        ; Set address ret will jump to for executing the scanline palette load
        push hl

        ; Save current palette buffer address
        ld a, l
        ld (_hicolor_palettes_cur_addr + 0), a
        ld a, h
        ld (_hicolor_palettes_cur_addr + 1), a

        xor a
        ldh (_IF_REG), a

        ld hl, #_BCPD_REG ; Palette load expects HL to point to BCPD
        ret               ; Jump to the palette load code

    ; Execution resumes here after hblank palette load returns
    5$:  ; hicol__hblank_load_pal_done_ret

        ld a, (_hicolor_last_scanline)
        ld c, a
        ldh a, (_LY_REG)
        cp c
        jr c, 4$  ; hicol__scanline_load_start ; If end of frame not reached then continue loading palettes

    ld a, (_STAT_SAVE)
    ldh (_STAT_REG), a
    xor a
    ldh (_IF_REG), a

    pop af
    ldh (__current_bank), a
    ld (_rROMB0), a

    ret
__endasm;
}


// Loads Tile Patterns, Map and Map Attributes for the HiColor image,
// then installs the HiColor ISR handler which updates palettes per scanline.
//
// The intput argument should be a pointer to the struct generated by the
// png2hicolorgb program with C source output mode enabled
void hicolor_start(const hicolor_data * p_hicolor, uint8_t hicolor_bank) NONBANKED {
    // prevent installing HiColor ISR twice
    CRITICAL {
        remove_LCD(hicolor_palette_isr);
    }

    if (!p_hicolor) return;
    hicolor_palettes_bank = hicolor_bank;

    uint8_t bank_save = _current_bank;
    if (hicolor_bank) SWITCH_ROM(hicolor_bank);

    // Copy address of palette into local var used by HiColor ISR
    p_hicolor_palettes = p_hicolor->p_palette;

    // TODO: if less than screen height, then converter must emit tail palettes and the cutting scanline must be moved accordingly
    hicolor_last_scanline = (p_hicolor->height_in_tiles > DEVICE_SCREEN_HEIGHT) ? (DEVICE_SCREEN_PX_HEIGHT - 1) : ((p_hicolor->height_in_tiles << 3) - 1);

    // Load the first 256 tiles or less and set BG Map
    VBK_REG = VBK_BANK_0;
    set_bkg_data(0u, MIN(p_hicolor->tile_count, 256), p_hicolor->p_tiles);
    set_bkg_tiles(0u, 0u, DEVICE_SCREEN_WIDTH, p_hicolor->height_in_tiles, p_hicolor->p_map);

    // Load remaining 256 tiles and set Attribute Map into alternate bank
    VBK_REG = VBK_BANK_1;
    if (p_hicolor->tile_count > 256) set_bkg_data(0u, (p_hicolor->tile_count - 256), p_hicolor->p_tiles + (256 * 16));
    set_bkg_tiles(0, 0, DEVICE_SCREEN_WIDTH, p_hicolor->height_in_tiles, p_hicolor->p_attribute_map);
    VBK_REG = VBK_BANK_0;

    SWITCH_ROM(bank_save);

    // Set up and install the HiColor ISR
    CRITICAL {
        LYC_REG = 152;
        STAT_REG = STATF_LYC;
        // install the HiColor ISR
        add_LCD(hicolor_palette_isr);
    }
    set_interrupts(IE_REG | LCD_IFLAG);
}
