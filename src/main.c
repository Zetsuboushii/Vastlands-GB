#define __TARGET_gb

#include <gb/cgb.h>
#include <gb/gb.h>
#include <gb/hardware.h>
#include <gb/metasprites.h>
#include <gbdk/emu_debug.h>
#include <gbdk/platform.h>
#include <palettes.h>
#include <stdbool.h>
#include <stdint.h>

// --- Our own includes ---
#include "camera.h"
#include "player.h"
#include "titlescreen.h"
#include <bkg.h>

// -----------------------------------------------------------------------------
// CONFIGURATION & CONSTANTS
// -----------------------------------------------------------------------------
#define LAST_TILE_INDEX 255u                  // The very last tile index in VRAM
#define TILEMAP_WIDTH (bkg_WIDTH >> 3)        // Width of the background tilemap in tiles
#define TILEMAP_HEIGHT (bkg_HEIGHT >> 3)      // Height of the background tilemap in tiles

#define TILE_SIZE 16                          // Typically, player sprite is 16x16
#define WALKING_SPEED 3                       // Player movement speed in pixels per frame
#define ARRAY_COUNT(arr) (sizeof(arr) / sizeof(arr[0]))

#define MIN(A, B) ((A) < (B) ? (A) : (B))
#define UPDATE_KEYS() (key_state_prev = key_state, key_state = joypad())  // Helper macro
#define KEY_NEW_PRESS(mask) ((key_state & ~key_state_prev) & (mask))
#define KEY_IS_PRESSED(mask) (key_state & (mask))

// -----------------------------------------------------------------------------
// VALID TILES FOR COLLISION DETECTION
// -----------------------------------------------------------------------------
#define NUM_VALID_TILES 21
const uint8_t valid_tiles[NUM_VALID_TILES] = {
    0x04, 0x05, 0x06, 0x0c, 0x0d, 0x2e, 0x33, 0x34, 0x79, 0x2d, 0xa3,
    0x38, 0x97, 0x98, 0x6e, 0xa4, 0x6f, 0x60, 0x53, 0x54, 0x61
};

// Input handling
uint8_t key_state, key_state_prev; // Current and previous joypad states
uint8_t joypad_current = 0; // For reading the joypad in main loop

// -----------------------------------------------------------------------------
// SPRITE TWO-FRAME COUNTER FOR ANIMATION
// -----------------------------------------------------------------------------
uint8_t two_frame_counter, two_frame_real_value = 0;
/**
 * @brief Updates two_frame_counter to alternate between two animation frames
 *        for walking animations. The variable two_frame_real_value becomes 0 or 1.
 */
void update_two_frame_counter() {
    // Increase the counter by a small amount
    two_frame_counter += 3;

    // Shift right to get either 0 or 1
    two_frame_real_value = two_frame_counter >> 4;

    // Once it reaches 2, reset to 0
    if (two_frame_real_value >= 2) {
        two_frame_real_value = 0;
        two_frame_counter = 0;
    }
}

// -----------------------------------------------------------------------------
// FUNCTION: is_valid_tile
// -----------------------------------------------------------------------------
/**
 * @brief Checks if a tile at the given pixel coordinates can be walked on.
 *        We compare the tile ID from the background tilemap against a list
 *        of valid tiles.
 *
 * @param x  The X position in pixels
 * @param y  The Y position in pixels
 * @return true if the tile is valid for movement, otherwise false
 */
bool is_valid_tile(uint16_t x, uint16_t y) {
    // Convert pixel coordinates to tile coordinates
    uint16_t tile_x = x / 8;
    uint16_t tile_y = y / 8;

    // If outside the tilemap, block movement
    if (tile_x > TILEMAP_WIDTH || tile_x < 1 || tile_y > TILEMAP_HEIGHT || tile_y < 1) {
        return false;
    }

    // Compute the index in bkg_map
    uint16_t index = (tile_y - 1) * TILEMAP_WIDTH + (tile_x - 1);
    uint16_t tile_dr;

    // Read from the correct ROM bank (where bkg_map is located)
    SWITCH_ROM_MBC5(2);
    tile_dr = bkg_map[index];
    SWITCH_ROM_MBC5(0);

    EMU_printf("Checking: Tile %x in %u,%u at %x\n", tile_dr, tile_y - 1, tile_x - 1, index);

    // Compare with our valid tile array
    for (uint8_t i = 0; i < ARRAY_COUNT(valid_tiles); i++) {
        if (tile_dr == valid_tiles[i]) {
            return true;
        }
    }
    return false;
}

// -----------------------------------------------------------------------------
// FUNCTION: get_tile_in_front_of_player
// -----------------------------------------------------------------------------
/**
 * @brief Gets the tile ID located in front of the player (one tile away
 *        in the player's facing direction).
 *
 * @return the tile ID (0xFF if invalid/out of bounds)
 */
uint8_t get_tile_in_front_of_player(void) {
    // Player's current pixel position
    int16_t front_x = (int16_t)player_x;
    int16_t front_y = (int16_t)player_y;

    // Move 8 pixels forward in the direction the player is facing
    switch (player_direction) {
    case J_UP: front_y -= 8;
        break;
    case J_DOWN: front_y += 8;
        break;
    case J_LEFT: front_x -= 8;
        break;
    case J_RIGHT: front_x += 8;
        break;
    }

    // Convert back to tile coordinates
    uint16_t tile_x = (uint16_t)(front_x >> 3);
    uint16_t tile_y = (uint16_t)(front_y >> 3);

    // If outside the tilemap, return 0xFF (invalid)
    if (tile_x < 1 || tile_x > TILEMAP_WIDTH || tile_y < 1 || tile_y > TILEMAP_HEIGHT) {
        return 0xFF;
    }

    // Calculate index in bkg_map
    uint16_t index = (tile_y - 1) * TILEMAP_WIDTH + (tile_x - 1);

    SWITCH_ROM_MBC5(2);
    uint8_t tile_id = bkg_map[index];
    SWITCH_ROM_MBC5(0);

    return tile_id;
}

// -----------------------------------------------------------------------------
// DIALOG WINDOW MECHANIC
// -----------------------------------------------------------------------------
/**
 * - A two-line dialog window that scrolls two lines of text each time A is pressed.
 * - B closes the dialog immediately.
 * - We draw text lines by writing into the window layer's tile data.
 */

// Offsets and other definitions for the dialog system
#define DIALOG_FIRST_ROW_START 0xD0
#define DIALOG_SECOND_ROW_START 0xE0
#define TILE_BLACK   0xF0
#define TILE_ARROW   0xF1
#define CHAR_OFFSET  32    // ' ' = ASCII 32 => index 0 in char_sprites

#define DIALOG_MAX_STRING_SIZE 17  // Up to 16 characters + 1 null terminator

// A blank black tile used for the dialog background
const unsigned char black_tile[16] = {
    0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF
};

// A small arrow tile (for dialog box edges or arrow pointer)
const unsigned char arrow_tile[16] = {
    0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0x83, 0x83,
    0xC7, 0xC7, 0xEF, 0xEF,
    0xFF, 0xFF, 0xFF, 0xFF
};

// A 96-character font set (ASCII 32..127).
// Each entry is one 8x8 tile (16 bytes).
const uint8_t char_sprites[96][16] = {
    // 0 - 31
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
    {0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0xFF, 0xE7, 0xE7, 0xFF, 0xFF},
    {0x99, 0x99, 0x99, 0x99, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xDB, 0xDB, 0x81, 0x81, 0xDB, 0xDB, 0xDB, 0xDB, 0x81, 0x81, 0xDB, 0xDB, 0xFF, 0xFF},
    {0xEB, 0xEB, 0xC1, 0xC1, 0xAA, 0xAA, 0xC3, 0xC3, 0xE1, 0xE1, 0xAA, 0xAA, 0xC1, 0xC1, 0xEB, 0xEB},
    {0x9D, 0x9D, 0x99, 0x99, 0xF3, 0xF3, 0xE7, 0xE7, 0xCF, 0xCF, 0x99, 0x99, 0xB9, 0xB9, 0xFF, 0xFF},
    {0x87, 0x87, 0x33, 0x33, 0x9E, 0x9E, 0x31, 0x31, 0x33, 0x33, 0x33, 0x33, 0x87, 0x87, 0xFF, 0xFF},
    {0xE7, 0xE7, 0xE7, 0xE7, 0xEF, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
    {0xF7, 0xF7, 0xEF, 0xEF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xEF, 0xEF, 0xF7, 0xF7},
    {0xDF, 0xDF, 0xEF, 0xEF, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xEF, 0xEF, 0xDF, 0xDF},
    {0xFF, 0xFF, 0xAB, 0xAB, 0xC7, 0xC7, 0x01, 0x01, 0xC7, 0xC7, 0xAB, 0xAB, 0xFF, 0xFF, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xE7, 0xE7, 0xE7, 0xE7, 0x81, 0x81, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xCF, 0xCF, 0xCF, 0xDF, 0xDF},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0xFF},
    {0xFD, 0xFD, 0xF9, 0xF9, 0xF3, 0xF3, 0xE7, 0xE7, 0xCF, 0xCF, 0x9F, 0x9F, 0x3F, 0x3F, 0xFF, 0xFF},
    {0xC3, 0xC3, 0x99, 0x99, 0x91, 0x91, 0x89, 0x89, 0x99, 0x99, 0x99, 0x99, 0xC3, 0xC3, 0xFF, 0xFF},
    {0xE7, 0xE7, 0xC7, 0xC7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0xFF},
    {0xC3, 0xC3, 0x99, 0x99, 0xF1, 0xF1, 0xE3, 0xE3, 0xC7, 0xC7, 0x8F, 0x8F, 0x81, 0x81, 0xFF, 0xFF},
    {0x81, 0x81, 0xF3, 0xF3, 0xE7, 0xE7, 0xC3, 0xC3, 0xF9, 0xF9, 0xB9, 0xB9, 0xC3, 0xC3, 0xFF, 0xFF},
    {0xF3, 0xF3, 0xE3, 0xE3, 0xD3, 0xD3, 0xB3, 0xB3, 0x81, 0x81, 0xF3, 0xF3, 0xF3, 0xF3, 0xFF, 0xFF},
    {0x81, 0x81, 0x9F, 0x9F, 0x83, 0x83, 0xF9, 0xF9, 0xF9, 0xF9, 0xB9, 0xB9, 0xC3, 0xC3, 0xFF, 0xFF},
    {0xE3, 0xE3, 0xDF, 0xDF, 0x9F, 0x9F, 0x83, 0x83, 0x99, 0x99, 0x99, 0x99, 0xC3, 0xC3, 0xFF, 0xFF},
    {0x81, 0x81, 0xF9, 0xF9, 0xF1, 0xF1, 0xE3, 0xE3, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0xFF},
    {0xC3, 0xC3, 0x99, 0x99, 0x99, 0x99, 0xC3, 0xC3, 0x99, 0x99, 0x99, 0x99, 0xC3, 0xC3, 0xFF, 0xFF},
    {0xC3, 0xC3, 0x99, 0x99, 0x99, 0x99, 0xC1, 0xC1, 0xF9, 0xF9, 0xF3, 0xF3, 0xC7, 0xC7, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0xFF, 0xE7, 0xE7, 0xE7, 0xE7, 0xEF, 0xEF, 0xFF, 0xFF},
    {0xF9, 0xF9, 0xF3, 0xF3, 0xE7, 0xE7, 0xCF, 0xCF, 0xE7, 0xE7, 0xF3, 0xF3, 0xF9, 0xF9, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF},
    {0x9F, 0x9F, 0xCF, 0xCF, 0xE7, 0xE7, 0xF3, 0xF3, 0xE7, 0xE7, 0xCF, 0xCF, 0x9F, 0x9F, 0xFF, 0xFF},
    {0xC3, 0xC3, 0xB9, 0xB9, 0xF9, 0xF9, 0xF3, 0xF3, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0xFF, 0xE7, 0xE7},
    // 32 - 63
    {0xC3, 0xC3, 0x99, 0x99, 0x91, 0x91, 0x95, 0x95, 0x91, 0x91, 0x9F, 0x9F, 0xC3, 0xC3, 0xFF, 0xFF},
    {0xC3, 0xC3, 0x99, 0x99, 0x99, 0x99, 0x81, 0x81, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xFF, 0xFF},
    {0x83, 0x83, 0x99, 0x99, 0x99, 0x99, 0x83, 0x83, 0x99, 0x99, 0x99, 0x99, 0x83, 0x83, 0xFF, 0xFF},
    {0xC3, 0xC3, 0x9D, 0x9D, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9D, 0x9D, 0xC3, 0xC3, 0xFF, 0xFF},
    {0x83, 0x83, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x83, 0x83, 0xFF, 0xFF},
    {0x81, 0x81, 0x9F, 0x9F, 0x9F, 0x9F, 0x83, 0x83, 0x9F, 0x9F, 0x9F, 0x9F, 0x81, 0x81, 0xFF, 0xFF},
    {0x81, 0x81, 0x9F, 0x9F, 0x9F, 0x9F, 0x83, 0x83, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0xFF, 0xFF},
    {0xC3, 0xC3, 0x9D, 0x9D, 0x9F, 0x9F, 0x91, 0x91, 0x99, 0x99, 0x99, 0x99, 0xC1, 0xC1, 0xFF, 0xFF},
    {0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x81, 0x81, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xFF, 0xFF},
    {0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0xFF},
    {0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xB9, 0xB9, 0xC3, 0xC3, 0xFF, 0xFF},
    {0x99, 0x99, 0x93, 0x93, 0x87, 0x87, 0x8F, 0x8F, 0x87, 0x87, 0x93, 0x93, 0x99, 0x99, 0xFF, 0xFF},
    {0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x83, 0x83, 0xFF, 0xFF},
    {0x03, 0x03, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x39, 0x39, 0x39, 0x39, 0xFF, 0xFF},
    {0x9D, 0x9D, 0x8D, 0x8D, 0x85, 0x85, 0xA1, 0xA1, 0xB1, 0xB1, 0xB9, 0xB9, 0xBD, 0xBD, 0xFF, 0xFF},
    {0xC3, 0xC3, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xC3, 0xC3, 0xFF, 0xFF},
    {0x83, 0x83, 0x99, 0x99, 0x99, 0x99, 0x83, 0x83, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0xFF, 0xFF},
    {0xC3, 0xC3, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xC3, 0xC3, 0xF9, 0xF9},
    {0x83, 0x83, 0x99, 0x99, 0x99, 0x99, 0x83, 0x83, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xFF, 0xFF},
    {0xC3, 0xC3, 0x9D, 0x9D, 0x8F, 0x8F, 0xC3, 0xC3, 0xF1, 0xF1, 0xB9, 0xB9, 0xC3, 0xC3, 0xFF, 0xFF},
    {0x81, 0x81, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0xFF},
    {0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xC3, 0xC3, 0xFF, 0xFF},
    {0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9B, 0x9B, 0x87, 0x87, 0xFF, 0xFF},
    {0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x03, 0x03, 0xFF, 0xFF},
    {0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xC3, 0xC3, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xFF, 0xFF},
    {0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xC3, 0xC3, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0xFF},
    {0x81, 0x81, 0xF1, 0xF1, 0xE3, 0xE3, 0xC7, 0xC7, 0x8F, 0x8F, 0x9F, 0x9F, 0x81, 0x81, 0xFF, 0xFF},
    {0xE1, 0xE1, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE1, 0xE1, 0xFF, 0xFF},
    {0xBF, 0xBF, 0x9F, 0x9F, 0xCF, 0xCF, 0xE7, 0xE7, 0xF3, 0xF3, 0xF9, 0xF9, 0xFD, 0xFD, 0xFF, 0xFF},
    {0x87, 0x87, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0x87, 0x87, 0xFF, 0xFF},
    {0xEF, 0xEF, 0xC7, 0xC7, 0x93, 0x93, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x81, 0x81, 0xFF, 0xFF},
    // 64 - 95
    {0xFF, 0xFF, 0x3F, 0x3F, 0x3F, 0x3F, 0x9F, 0x9F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xC3, 0xC3, 0xB9, 0xB9, 0xC1, 0xC1, 0x99, 0x99, 0x99, 0x99, 0xC1, 0xC1, 0xFF, 0xFF},
    {0x9F, 0x9F, 0x83, 0x83, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x83, 0x83, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xC3, 0xC3, 0x9D, 0x9D, 0x9F, 0x9F, 0x9F, 0x9F, 0x9D, 0x9D, 0xC3, 0xC3, 0xFF, 0xFF},
    {0xF9, 0xF9, 0xC1, 0xC1, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xC1, 0xC1, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xC3, 0xC3, 0x99, 0x99, 0x81, 0x81, 0x9F, 0x9F, 0x9D, 0x9D, 0xC3, 0xC3, 0xFF, 0xFF},
    {0xE1, 0xE1, 0xCF, 0xCF, 0x83, 0x83, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xC1, 0xC1, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xC1, 0xC1, 0xB9, 0xB9, 0xC3, 0xC3},
    {0x9F, 0x9F, 0x83, 0x83, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xFF, 0xFF},
    {0xE7, 0xE7, 0xFF, 0xFF, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xF7, 0xF7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xA7, 0xA7, 0xCF, 0xCF},
    {0x9F, 0x9F, 0x9B, 0x9B, 0x97, 0x97, 0x8F, 0x8F, 0x87, 0x87, 0x93, 0x93, 0x99, 0x99, 0xFF, 0xFF},
    {0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xF3, 0xF3, 0xFF, 0xFF},
    {0xFF, 0xFF, 0x03, 0x03, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x39, 0x39, 0xFF, 0xFF},
    {0xFF, 0xFF, 0x83, 0x83, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xC3, 0xC3, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xC3, 0xC3, 0xFF, 0xFF},
    {0xFF, 0xFF, 0x83, 0x83, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x83, 0x83, 0x9F, 0x9F, 0x9F, 0x9F},
    {0xFF, 0xFF, 0xC1, 0xC1, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xC1, 0xC1, 0xF9, 0xF9},
    {0xFF, 0xFF, 0x93, 0x93, 0x8F, 0x8F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xC3, 0xC3, 0x8D, 0x8D, 0xC7, 0xC7, 0xE3, 0xE3, 0xB1, 0xB1, 0xC3, 0xC3, 0xFF, 0xFF},
    {0xE7, 0xE7, 0xC3, 0xC3, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xF3, 0xF3, 0xFF, 0xFF},
    {0xFF, 0xFF, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xC1, 0xC1, 0xFF, 0xFF},
    {0xFF, 0xFF, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9B, 0x9B, 0x87, 0x87, 0xFF, 0xFF},
    {0xFF, 0xFF, 0x39, 0x39, 0x39, 0x39, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x03, 0x03, 0xFF, 0xFF},
    {0xFF, 0xFF, 0x99, 0x99, 0x99, 0x99, 0xC3, 0xC3, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xFF, 0xFF},
    {0xFF, 0xFF, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD9, 0xD9, 0xE1, 0xE1, 0xB9, 0xB9, 0xC3, 0xC3},
    {0xFF, 0xFF, 0x81, 0x81, 0xF1, 0xF1, 0xE3, 0xE3, 0xC7, 0xC7, 0x8F, 0x8F, 0x81, 0x81, 0xFF, 0xFF},
    {0xF1, 0xF1, 0xE7, 0xE7, 0xE7, 0xE7, 0xCF, 0xCF, 0xE7, 0xE7, 0xE7, 0xE7, 0xF1, 0xF1, 0xFF, 0xFF},
    {0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7},
    {0x8F, 0x8F, 0xE7, 0xE7, 0xE7, 0xE7, 0xF3, 0xF3, 0xE7, 0xE7, 0xE7, 0xE7, 0x8F, 0x8F, 0xFF, 0xFF},
    {0xFF, 0xFF, 0x9F, 0x9F, 0x0D, 0x0D, 0x61, 0x61, 0xF3, 0xF3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
    {0xEF, 0xEF, 0xEF, 0xEF, 0xD7, 0xD7, 0xD7, 0xD7, 0xBB, 0xBB, 0xBB, 0xBB, 0x7D, 0x7D, 0x01, 0x01},
};

// Example text: 4 lines, each up to 16 chars long
const unsigned char pangram_a[][DIALOG_MAX_STRING_SIZE] = {
    "Es scheint      ",
    "niemand zu      ",
    "Hause zu        ",
    "sein...         "
};

// Global flags / variables for the dialog window
UBYTE dialog_window_visible = 0; // 1 if the dialog window is open
uint8_t current_line_index = 0; // Which line to show next
UBYTE key_down = 0; // Helps to avoid repeated input when the button is held

// This tilemap is used to set up an 18x5 region in the window layer
// for the 2 lines of text plus some borders.
const unsigned char dia_wnd_tilemap[] = {
    // Row 0 (top edge)
    TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK,
    TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK,
    TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK,
    TILE_BLACK, TILE_BLACK, TILE_BLACK,

    // Row 1 (first text line)
    TILE_BLACK, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
    0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
    TILE_BLACK,

    // Row 2 (second text line)
    TILE_BLACK, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
    0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
    TILE_BLACK,

    // Row 3 (bottom edge)
    TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK,
    TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK,
    TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK,
    TILE_BLACK, TILE_BLACK, TILE_BLACK,

    // Row 4 (border / arrow)
    TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK,
    TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK,
    TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK, TILE_BLACK,
    TILE_BLACK, TILE_BLACK, TILE_ARROW
};

// -----------------------------------------------------------------------------
// FUNCTION: show_dia_wnd
// -----------------------------------------------------------------------------
/**
 * @brief Copies 2 lines from 'text_lines' into the window layer tile memory
 *        and updates the window tilemap. This function returns the new line
 *        index after adding 2 lines. If we hit the end, we don't overwrite
 *        beyond it.
 *
 * @param text_lines  2D array of text lines
 * @param amount_lin  total number of lines in 'text_lines'
 * @param last_lin    the index of the line we want to start printing
 * @return new line index (last_lin + 2) or the line count if we can't go further
 */
uint8_t show_dia_wnd(const unsigned char text_lines[][DIALOG_MAX_STRING_SIZE],
                     uint8_t amount_lin,
                     uint8_t last_lin) {
    dialog_window_visible = 1;

    // Load black tile & arrow tile into the window tile data (WIN VRAM)
    set_win_data(TILE_BLACK, 1, black_tile);
    set_win_data(TILE_ARROW, 1, arrow_tile);

    // Fill 32 tiles with black (2 lines x 16 columns)
    for (uint8_t i = 0; i < 32; i++) {
        set_win_data(DIALOG_FIRST_ROW_START + i, 1, black_tile);
    }

    // Write 2 lines of text into the window
    for (uint8_t row = 0; row < 2; row++) {
        // If we exceed total lines, stop
        if ((row + last_lin) >= amount_lin) break;

        for (uint8_t col = 0; col < 16; col++) {
            // Grab one character
            unsigned char c = text_lines[row + last_lin][col];
            // Subtract CHAR_OFFSET (32) since ASCII 32 maps to char_sprites[0]
            set_win_data(DIALOG_FIRST_ROW_START + (row * 16) + col,
                         1,
                         char_sprites[c - CHAR_OFFSET]);
        }
    }

    // Set the tilemap of the window layer to 18 wide x 5 tall
    set_win_tiles(0, 0, 18, 5, dia_wnd_tilemap);

    // Position the window somewhere near the bottom
    move_win(15, 104);
    SHOW_WIN;

    // Return updated line index (last_lin + 2)
    uint8_t new_pos = last_lin + 2;
    if (new_pos > amount_lin) {
        new_pos = amount_lin;
    }
    return new_pos;
}

// -----------------------------------------------------------------------------
// MAIN
// -----------------------------------------------------------------------------
/**
 * @brief Main entry point of the game. Loads the title screen, sets up the
 *        player and camera, and runs the main loop that checks for input,
 *        updates the player, handles the dialog window, etc.
 */
void main(void) {
    SHOW_BKG;

    // Check if running on a CGB (Game Boy Color)
    if (_cpu == CGB_TYPE) {
        cpu_fast(); // Switch to double-speed mode on GBC, as hi-color needs the extra CPU
        vsync();
        DISPLAY_OFF;

        // Title screen
        show_titlescreen();
        DISPLAY_ON;
        while (is_title_shown) {
            UPDATE_KEYS();
            if (KEY_IS_PRESSED(J_START)) {
                cancel_titlescreen();
            }
        }

        cpu_slow(); // Switch to "normal" speed to save battery

        // Set up sprites
        SHOW_SPRITES;
        SPRITES_8x16;
        setup_player();

        // Initialize camera
        uint16_t init_cam_x = player_x - (160 >> 1);
        uint16_t init_cam_y = player_y - (144 >> 1);
        init_camera(init_cam_x, init_cam_y);

        // Main game loop
        while (true) {
            UPDATE_KEYS();
            joypad_current = joypad();

            // --- 1) Dialog input check (A/B) ---
            if (key_down) {
                // Wait until button is released to avoid repeated triggers
                waitpadup();
                key_down = 0;
            }

            switch (joypad_current) {
            case J_A:
                if (dialog_window_visible) {
                    // If dialog is already open, either go to next lines or close
                    uint8_t total_lines = (sizeof(pangram_a) / DIALOG_MAX_STRING_SIZE);
                    if (current_line_index >= total_lines) {
                        // All lines shown => close
                        HIDE_WIN;
                        dialog_window_visible = 0;
                        current_line_index = 0;
                    } else {
                        // Show the next two lines
                        current_line_index = show_dia_wnd(
                            pangram_a,
                            total_lines,
                            current_line_index
                        );
                    }
                } else {
                    // If the window is closed, check the tile in front of the player
                    uint8_t tile_in_front = get_tile_in_front_of_player();
                    // If tile_in_front is 0x8F or 0x90, we open the dialog
                    if ((tile_in_front == 0x8F) || (tile_in_front == 0x90)) {
                        current_line_index = 0;
                        uint8_t total_lines = (sizeof(pangram_a) / DIALOG_MAX_STRING_SIZE);
                        current_line_index = show_dia_wnd(
                            pangram_a,
                            total_lines,
                            current_line_index
                        );
                    } else {
                        // Otherwise do nothing or attack logic
                    }
                }
                key_down = 1;
                break;

            case J_B:
                // Close the dialog window if open
                if (dialog_window_visible) {
                    HIDE_WIN;
                    dialog_window_visible = 0;
                    current_line_index = 0;
                }
                key_down = 1;
                break;
            }

            // --- 2) Update player only if no dialog is active ---
            if (!dialog_window_visible) {
                // Move the player, handle collisions, etc.
                update_two_frame_counter();
                uint8_t last_sprite = update_player();
                // Hide any unused sprites
                hide_sprites_range(last_sprite, 40);
            } else {
                // If window is active, we can freeze the player if desired
                hide_sprites_range(0, 40);
            }

            // Update sprite palettes
            set_sprite_palette(0, palettes_PALETTE_COUNT, palettes_palettes);

            // Wait for the next frame
            wait_vbl_done();
        }
    }
}
